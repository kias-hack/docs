Создание бэкапов mysql  
=======
Для создания бэкапов используется утилита `mysqldump`  

>mysqldump \<params\>; \<database | (database, database, ...)\>; \<table\>;
  
Возможные параметры этой утилиты:  
`-u` `--user` имя пользователя  
`-p` `--password` запросить пароль  
`-h` `--host` хост  
`--where` условие выбора данных к примеру `--where="true limit 100"` - выбирает не более 100 записей  
`--no-data` не бэкапирует данные, только структуру  
`--ignore-table=DATABASE.table1` не выключает таблицу в бэкап, необходимо укзазать вначале название БД

Примеры вызова
>mysqldump -uroot -p -hlocalhost my_base my_table > table_dump.sql  
>>делаем дамп таблицы my_table в базе my_base под пользователем root с запросом пароля  

>mysqldump -uroot -p -hlocalhost my_base --where="true limit 100" > dev_dump.sql  
>>делаем дамп базы выбирая не больше 100 записей из каждой таблицы, подойдет например для dev копии  

>mysqldump -uroot -p -hlocalhost my_base --where="true limit 100" | gzip > dev_dump.sql.gz  
>>делаем дамп базы с предварительным сжатием  

Восстановление базы из бэкапа  
=======

Для восстановления базы из бэкапа используется утилита `mysql`  

>mysql \<params\> \<database | (database, database, ...)\> \<table\>  

Параметры утилиты:
`-u` `--user` имя пользователя  
`-p` `--password` запросить пароль  
`-h` `--host` хост  

Пример использования:

>mysql -uroot -p -hlocalhost my_base \< base_dump.sql
>>Восстанавливаем базу из файла полученную при бэкапе

>Желательно очищать базу перед восстановлением. Хотя существующие таблицы перезаписываются и без проблем восстанавливается без предварительной очистки, по крайней мере на малых проектах

Восстановление поврежденных таблиц
=======
Сначала можно проверить таблицу на исправность
>mysql\> use db_name;  
>mysql\> check table db_table;  

Отобразится таблица в которой с столбце `Msg_text` будет статус этой таблицы  

### Метод для таблиц MyISAM

Для восстановления таблицы используется SQL команда  
>mysql\> repair table db_table;  

### Метод для таблиц innoDB

* Необходимо восстановить доступ к поврежденной таблице, т.к. mysql сервер не запускается при повреждении таблиц innoDB (хотя он может и сам их исправлять)  
* Селать дамп этой таблицы  
* Уалить поврежденную таблицу  
* Загрузить данную таблицу в базу из созданного дампа  
Для востановления доступа к поврежденной таблице необходимо запустить mysql с опцией `inodb_force_recovery=1`. Для этого необходимо отредактировать конфигурационный файл `/etc/mysql/mysql.conf.d/mysqld.cnf`  
Необбходимо в раздел `[mysqld]` добавить строку `inodb_force_recovery=1`

Если запрос грузит процессор и не завершается
==

>SHOW FULL PROCESSLIST;

>KILL QUERY id_процесса;

Если таблица была заблокирована и не разблокирована (к примеру при исполнении скрипта с блокировками произошла остановка программы). Нужно закрыть соединение, для этого
==

>SHOW FULL PROCESSLIST;  
>KILL id_процесса;  

Если таблица занимает больше места чем в ней есть данных
==

С помощтю команды

>SHOW TABLE STATUS LIKE `table_name`\G;

Смотрим вывод статистики по таблице. Если в поле Data_free очень блоьшое значение (размер в байтах) то можно это исправить ребилдом таблицы

>ALTER TABLE `table_name` Engine=InnoDB;

Также можно запустить оптимизацию на этой таблице

>OPTIMIZE TABLE `table_name`;

Репликация баз данных
==

Имеем 2 сервера - мастер (192.168.0.2) и реплика (192.168.0.3)

Необходимо настроить iptables на обоих серверах таким образом, что-бы к порту 3306 (если у БД он не сменен) был обоюдный доступ только с свервера репликации и мастера.
Меняем bind-server с 127.0.0.1 на ip в сети (к примеру с интерфейса eth0) или пробрасываем порт на 127.0.0.1 на обоих серверах

## Настраиваем мастер

правим конфигурацию mysql в блоке [mysqld]

> bind-server = 192.168.0.2  
> server-id 1  
> log-bin = /var/lib/mysql/mysql-bin # необходимо настроить очитску бинарных логов в соответсвии с нагрузкой  
> replicate-do-db = testdb  

Добавим пользователя от имени которого будет производиться репликация и дадим соответствующие привилегии

> GRANT replication slave ON "testdb".* TO "replication"@"192.168.1.102" IDENTIFIED BY "password";  

## Настраиваем реплику

Вносим правки в конфиг в блоке [mysqld]

> server-id = 2
> bind-address = 192.168.0.3  
> relay-log = /var/lib/mysql/mysql-relay-bin  
> relay-log-index = /var/lib/mysql/mysql-relay-bin.index  
> replicate-do-db = testdb  

## Переносим данные

Здесь нам придется заблокировать БД для записи. Для этого можно либо остановить работу приложений, либо воспользоваться установкой флажка read_only на мастере. 

> FLUSH TABLES WITH READ LOCK;  
> SET GLOBAL read_only = ON;  

Cмотрим состояние мастера командой «show master status» и запомним значения File и Position (после успешной блокировки мастера они не должны изменятся)

Делаем дамп БД, и после завершения операции снимаем блокировку мастера:
> SET GLOBAL read_only = OFF;  

Переносим дамп на реплику и восстанавливаем из него данные.

Запускаем репликацию командами "change master to" и "start slave" на `реплике` и смотрим, все ли прошло хорошо.
> CHANGE MASTER TO MASTER_HOST = "192.168.1.101 ", MASTER_USER = "replication ", MASTER_PASSWORD = "password ", MASTER_LOG_FILE = "mysql-bin.000003 ", MASTER_LOG_POS = 98;  
> start slave;  

Значения MASTER_LOG_FILE и MASTER_LOG_POS мы берем с мастера.

Посмотреть как идет репликация можно командой
> SHOW SLAVE STATUS;

Должно быть так, если нет то ищем причину.
`Slave_IO_State: Waiting for master to send event`



 
